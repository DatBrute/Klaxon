extends KinematicBody2D

const points = [Vector2(0, 100), Vector2(-50, 0), Vector2(50, 0)]


const acceleration = 100
const deceleration = 100
# speed, seconds to 360, turn rate (1 or the other). Does not require even intervals.
const power_curve = [ 
	[0, 100, null],
	[250, 4, null],
	[500, 3, null],
	[1000, 0.1, null]
]

const roll_time = 2
var current_roll = 0
var auto_level = false

const TRAIL_LENGTH = 120
var trail = []

func _ready():
	for i in range(power_curve.size()): # either turn rate or turn radius must be defined
		if(power_curve[i][1] == null):
			power_curve[i][1] = 360.0 * power_curve[i][2] 
		elif(power_curve[i][2] == null):
			 power_curve[i][2] = 360.0 / power_curve[i][1]
		else:
			assert(power_curve[i][1].is_equal_approx(360.0 * power_curve[i][2]))

# ignores roll
func rspeed ():
	for i in range(0, power_curve.size()-1):
		var a = power_curve[i][0]
		var b =  power_curve[i+1][0]
		if(a <= speed and b >= speed):
			var diff = (speed - a) / (b-a)
			# speed is lerped between the two, radius is not
			var rspeed = (1-diff) * power_curve[i][2] + diff * power_curve[i+1][2]
			var rtime = 360 / rspeed
			var r_radius = speed * rtime
			$"../UI/BottomText".text = ("spd: %.0f, rtime: %.1f, rrad: %.0f, roll: %.1f %s" % \
				[speed, rtime, r_radius, current_roll, "A" if auto_level else ""])
			return rspeed
	assert(speed <= max_speed())
	return power_curve[power_curve.size()-1][1]
	
func r_radius ():
	for i in range(0, power_curve.size()-1):
		var a = power_curve[i][0]
		var b =  power_curve[i+1][0]
		if(a <= speed and b >= speed):
			var diff = (speed - a) / (b-a)
			# speed is lerped between the two, radius is not
			var r_speed = (1-diff) * power_curve[i][2] + diff * power_curve[i+1][2]
			var r_time = 360 / r_speed
			var r_radius = speed * r_time / PI
			return r_radius
	return 0
	

func max_speed():
	return power_curve[power_curve.size()-1][0]

func min_speed():
	return power_curve[0][0]

func clamp_speed():
	speed = clamp(speed, min_speed(), max_speed())


var speed = 0

func _physics_process(delta):
	var r = deg2rad(rspeed())*delta
	if(!$"../".cli_activated):
		if Input.is_action_pressed('accelerate'):
			speed += acceleration * delta
			clamp_speed()
		if Input.is_action_pressed('decelerate'):
			speed -= deceleration * delta
			clamp_speed()
		if Input.is_action_pressed('turn_left'):
			current_roll = clamp(current_roll - delta/roll_time, -1.0, 1.0)
		elif Input.is_action_pressed('turn_right'):
			current_roll = clamp(current_roll + delta/roll_time, -1.0, 1.0)
		elif auto_level: 
			if(current_roll < 0):
				current_roll = clamp(current_roll  + delta/roll_time, -1.0, 0)
			else:
				current_roll = clamp(current_roll - delta/roll_time, 0, 1.0)
	rotate(r * current_roll)
	move_and_collide(Vector2(0, speed*delta).rotated(rotation))
	trail.append(global_position)
	if(trail.size() > TRAIL_LENGTH):
		trail.pop_front()
		
func _input(event):
	if event.is_action_pressed("reset_roll"):
		auto_level = not auto_level

func _process(_delta):
	update()

func _draw():
	draw_polyline(points + [points[0]], Color.blue)
	var trail_draw = []
	if trail.size() >= 2:
		for point in trail:
			trail_draw.append(to_local(point))
			pass
		draw_polyline(trail_draw, Color.red)

	# draw_arc(Vector2(r_radius/2,0), abs(r_radius)/2, 0, 2*PI, 100, Color.black)
	if(abs(current_roll) >= 0.01):
		var r_radius = r_radius() / current_roll
		var color = Color.gray
		color.a = 0.05
		draw_circle(Vector2(-r_radius,0), 10, color)
